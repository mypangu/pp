<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Advanced Video Player - PanguPlay</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  background: #0a0a0a;
  color: #fff;
  overflow: hidden;
  height: 100dvh; /* Use dynamic viewport height */
  margin: 0;
  padding: 0;
  position: fixed;
  width: 100%;
  top: 0;
  left: 0;
}

/* Fallback for browsers that don't support dvh */
@supports not (height: 100dvh) {
  body {
    height: 100vh;
  }
  .player-container {
    height: 100vh;
  }
}

.player-container {
  position: relative;
  width: 100%;
  height: 100dvh; /* Use dynamic viewport height */
  margin: 0;
  background: #000;
}

.video-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
  background: #000;
  cursor: none; /* Hide cursor by default */
}

/* Show cursor when controls are visible or mouse is moving */
.video-wrapper.show-cursor {
  cursor: default;
}

    video {
      width: 100%;
      height: 100%;
      display: block;
      transition: object-fit 0.3s ease;
    }

    video.fit { object-fit: contain; }
    video.fill { object-fit: cover; }
    video.stretch { object-fit: fill; }
    video.zoom { object-fit: cover; transform: scale(1.5); }

    /* Loading Spinner */
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
      display: none;
    }

    .loading.show { display: block; }

    .spinner {
      border: 4px solid rgba(255,255,255,0.1);
      border-top: 4px solid #ff4500;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Custom Controls */
    .controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.9));
      padding: 20px 15px 15px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 50;
    }

    .controls.show {
      opacity: 1;
    }
	
	body:not(.video-loaded) .controls {
  opacity: 1;
}

body:not(.video-loaded) .top-controls {
  opacity: 1;
}

    .progress-bar {
      width: 100%;
      height: 5px;
      background: rgba(255,255,255,0.3);
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 10px;
      position: relative;
    }

    .progress-filled {
      height: 100%;
      background: #ff4500;
      border-radius: 5px;
      width: 0%;
      transition: width 0.1s;
    }

    .progress-buffer {
      position: absolute;
      height: 100%;
      background: rgba(255,255,255,0.5);
      border-radius: 5px;
      width: 0%;
    }

    .control-buttons {
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    .control-buttons button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      padding: 5px;
      transition: color 0.2s;
    }

    .control-buttons button:hover {
      color: #ff4500;
    }

    .time-display {
      font-size: 14px;
      color: #fff;
    }

    .spacer {
      flex: 1;
    }

    /* Top Controls */
    .top-controls {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 15px;
      background: linear-gradient(rgba(0,0,0,0.9), transparent);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 15px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 50;
    }

    .top-controls.show {
      opacity: 1;
    }

    .top-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      flex-shrink: 0;
    }

    .top-btn:hover {
      background: rgba(255,69,0,0.8);
    }

    .video-title {
      font-size: 18px;
      font-weight: 600;
      flex: 1;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding: 0 10px;
    }

    /* Settings Menu */
    .settings-menu {
      position: absolute;
      bottom: 60px;
      right: 15px;
      background: rgba(20,20,20,0.95);
      border-radius: 8px;
      padding: 10px 0;
      min-width: 200px;
      display: none;
      z-index: 60;
      backdrop-filter: blur(10px);
    }

    .settings-menu.show {
      display: block;
    }

    .menu-item {
      padding: 12px 20px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
      font-size: 14px;
    }

    .menu-item:hover {
      background: rgba(255,255,255,0.1);
    }

    .menu-item.active {
      color: #ff4500;
    }

    .menu-section {
      border-top: 1px solid rgba(255,255,255,0.1);
      margin-top: 5px;
      padding-top: 5px;
    }

    /* Episode Selector */
    .episode-selector {
      position: absolute;
      bottom: 70px;
      left: 0;
      right: 0;
      background: rgba(20,20,20,0.98);
      backdrop-filter: blur(10px);
      padding: 20px;
      display: none;
      max-height: 300px;
      overflow-y: auto;
      z-index: 60;
      border-top: 2px solid #333;
    }

    .episode-selector.show {
      display: block;
    }

    .episode-selector h3 {
      margin-bottom: 15px;
      color: #ff4500;
    }

    .episode-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }

    .episode-btn {
      padding: 12px;
      background: #2a2a2a;
      border: 2px solid transparent;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }

    .episode-btn:hover {
      background: #3a3a3a;
    }

    .episode-btn.active {
      border-color: #ff4500;
      background: #ff4500;
    }

    /* Toast Notification */
    .toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
    }

    /* HUD Overlay for gestures */
    .hud {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 20px 30px;
      border-radius: 12px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 80;
    }

    .hud.show {
      display: flex;
    }

    .hud i {
      font-size: 36px;
      margin-bottom: 10px;
    }

    .hud-text {
      font-size: 18px;
    }

    /* Tap Zones for seeking */
    .tap-zone {
      position: absolute;
      top: 0;
      width: 30%;
      height: 100%;
      z-index: 40;
    }

    .tap-zone-left { left: 0; }
    .tap-zone-right { right: 0; }

    /* Fullscreen specific styles */
    .video-wrapper:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
    }

    .video-wrapper:-moz-full-screen {
      width: 100vw;
      height: 100vh;
    }

    .video-wrapper:fullscreen {
      width: 100vw;
      height: 100vh;
    }

    /* Fullscreen Episode Selector */
    .video-wrapper:fullscreen .episode-selector {
      max-height: 50vh;
    }

    @media (max-width: 768px) {
      .control-buttons {
        gap: 8px;
      }

      .control-buttons button {
        font-size: 16px;
        padding: 3px;
      }

      .video-title {
        font-size: 14px;
      }

      .top-btn {
        width: 35px;
        height: 35px;
        font-size: 16px;
      }

      .time-display {
        font-size: 12px;
      }

      .episode-selector {
        max-height: 200px;
        padding: 15px;
      }

      .episode-grid {
        grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
        gap: 8px;
      }

      .episode-btn {
        padding: 10px 8px;
        font-size: 13px;
      }

      .settings-menu {
        bottom: 65px;
        right: 10px;
        min-width: 180px;
      }

      .controls {
        padding: 15px 10px 10px;
      }

      .top-controls {
        padding: 10px;
      }

      /* Hide less important buttons on mobile */
      #rewindBtn,
      #forwardBtn,
      #castBtn {
        display: none;
      }
    }

    @media (max-width: 480px) {
      .video-title {
        font-size: 12px;
        padding: 0 5px;
      }

      .control-buttons {
        gap: 6px;
      }

      .control-buttons button {
        font-size: 14px;
      }

      .top-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div class="player-container">
    <!-- Video Wrapper -->
    <div class="video-wrapper">
      <!-- Video Element -->
      <video id="videoPlayer" class="fit" preload="metadata"></video>

      <!-- Loading Spinner -->
      <div class="loading" id="loading">
        <div class="spinner"></div>
      </div>

      <!-- HUD for gestures -->
      <div class="hud" id="hud">
        <i id="hudIcon" class="fas fa-volume-up"></i>
        <div class="hud-text" id="hudText">50%</div>
      </div>

      <!-- Tap Zones -->
      <div class="tap-zone tap-zone-left" id="tapLeft"></div>
      <div class="tap-zone tap-zone-right" id="tapRight"></div>

      <!-- Top Controls -->
      <div class="top-controls" id="topControls">
        <button class="top-btn" id="backBtn" title="Go Back">
          <i class="fas fa-arrow-left"></i>
        </button>
        <div class="video-title" id="videoTitle">Video Player</div>
		<button class="top-btn" id="reloadBtn" title="Reload">
		  <i class="fas fa-rotate-right"></i>
		</button>
        <button class="top-btn" id="shareBtn" title="Share">
          <i class="fas fa-share-alt"></i>
        </button>
      </div>

      <!-- Bottom Controls -->
      <div class="controls" id="controls">
        <div class="progress-bar" id="progressBar">
          <div class="progress-buffer" id="progressBuffer"></div>
          <div class="progress-filled" id="progressFilled"></div>
        </div>
        
        <div class="control-buttons">
          <button id="playPauseBtn" title="Play/Pause"><i class="fas fa-play"></i></button>
          <button id="rewindBtn" title="Rewind 10s"><i class="fas fa-rotate-left"></i></button>
          <button id="forwardBtn" title="Forward 10s"><i class="fas fa-rotate-right"></i></button>
          <button id="nextEpisodeBtn" title="Next Episode" style="display:none;"><i class="fas fa-step-forward"></i></button>
          <button id="volumeBtn" title="Mute/Unmute"><i class="fas fa-volume-up"></i></button>
          <div class="time-display">
            <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
          </div>
          <div class="spacer"></div>
          <button id="episodesBtn" title="Episodes" style="display:none;"><i class="fas fa-list"></i></button>
		  <button id="linkBtn" title="Copy Link"><i class="fas fa-link"></i></button>
          <button id="downloadBtn" title="Download"><i class="fas fa-download"></i></button>
          <button id="castBtn" title="Cast"><i class="fas fa-tv"></i></button>
          <button id="settingsBtn" title="Settings"><i class="fas fa-cog"></i></button>
          <button id="fullscreenBtn" title="Fullscreen"><i class="fas fa-expand"></i></button>
        </div>
      </div>

      <!-- Settings Menu -->
      <div class="settings-menu" id="settingsMenu">
<div class="menu-item" id="qualityMenu" style="display: none;">
  <span>Quality</span>
  <span id="currentQuality">Auto</span>
</div>
        <div class="menu-section" id="qualityOptions" style="display:none;">
          <!-- Quality options will be added dynamically -->
        </div>
        <div class="menu-item" id="aspectMenu">
          <span>Aspect Ratio</span>
          <span id="currentAspect">Fit</span>
        </div>
        <div class="menu-section" id="aspectOptions" style="display:none;">
          <div class="menu-item aspect-option" data-mode="fit">Fit to Screen</div>
          <div class="menu-item aspect-option" data-mode="fill">Fill Screen</div>
          <div class="menu-item aspect-option" data-mode="stretch">Stretch</div>
          <div class="menu-item aspect-option" data-mode="zoom">Zoom</div>
        </div>
        <div class="menu-item" id="speedMenu">
          <span>Playback Speed</span>
          <span id="currentSpeed">1x</span>
        </div>
        <div class="menu-section" id="speedOptions" style="display:none;">
          <div class="menu-item speed-option" data-speed="0.5">0.5x</div>
          <div class="menu-item speed-option" data-speed="0.75">0.75x</div>
          <div class="menu-item speed-option" data-speed="1" class="active">1x</div>
          <div class="menu-item speed-option" data-speed="1.25">1.25x</div>
          <div class="menu-item speed-option" data-speed="1.5">1.5x</div>
          <div class="menu-item speed-option" data-speed="2">2x</div>
        </div>
      </div>

      <!-- Episode Selector -->
      <div class="episode-selector" id="episodeSelector">
        <h3>Select Episode</h3>
        <div class="episode-grid" id="episodeGrid"></div>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>
  
  <script disable-devtool-auto='true'
src='https://cdn.jsdelivr.net/npm/disable-devtool'
clear-log='true'
disable-select='true' 
disable-copy='true'
disable-cut='true' 
disable-paste='false'>
</script>

  <script>
    // ===== PLAYER STATE =====
    const player = {
      video: document.getElementById('videoPlayer'),
      data: null,
      currentSource: null,
      currentQuality: '1080p',
      aspectMode: 'fit',
      episodes: [],
      currentEpisodeIndex: 0,
      currentEpisodeId: null,
	  currentEpisode: null,
      resumeData: {},
      isPlaying: false,
      controlsTimeout: null,
	  isPinching: false,
	  isDoubleTapping: false
    };

    // ===== WORKER FETCH LOGIC =====
async function fetchFromWorker(lookUrl) {
  try {
    const workerUrl = `https://md.porus-in2012.workers.dev/?target=${encodeURIComponent(lookUrl)}`;
    console.log('Worker URL:', workerUrl);
    
    const response = await fetch(workerUrl);
    console.log('Worker response status:', response.status);
    
    if (!response.ok) {
      console.error('Worker response not OK:', response.status, response.statusText);
      throw new Error(`Worker fetch failed: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('Worker response data:', data);
    
    if (data && data.video) {
      console.log('Worker returned video URL:', data.video);
      return {
        videoUrl: data.video,
        downloadUrl: data.link || data.video
      };
    }
    
    console.warn('Worker response missing video field');
    return null;
  } catch (error) {
    console.error('Worker fetch error:', error.message, error);
    return null;
  }
}

    // ===== INITIALIZATION =====
async function init() {
  const urlParams = new URLSearchParams(window.location.search);
  const id = urlParams.get('id');
  const directUrl = urlParams.get('url');

  // Load resume data FIRST, before loading videos
  loadResumeData();

  if (directUrl) {
    await loadDirectVideo(decodeURIComponent(directUrl));
  } else if (id) {
    await loadFromDatabase(id);
  } else {
    showToast('No video source provided');
  }

  setupEventListeners();
}

    // ===== LOAD VIDEO =====
async function loadDirectVideo(url) {
  player.data = { title: 'Video Player', type: 'movie' };
  player.currentSource = { videoUrl: url, downloadUrl: url };
  player.currentEpisodeId = 'direct-video';
  document.getElementById('videoTitle').textContent = 'Video Player';
  document.title = 'Video Player - PanguPlay';
  
  // Hide quality menu for direct video
  document.getElementById('qualityMenu').style.display = 'none';
  
  loadVideoSource(url, true);
}

    async function loadFromDatabase(id) {
      try {
        showLoading();
        const response = await fetch('player.json');
        const database = await response.json();
        const data = database.find(item => item.id === id);
        
        if (!data) {
          showToast('Video not found');
          return;
        }

        player.data = data;
        document.getElementById('videoTitle').textContent = data.title;
		document.title = data.title + ' - PanguPlay';

if (data.type === 'series' && data.episodes) {
  player.episodes = data.episodes;
  document.getElementById('episodesBtn').style.display = 'block';
  
  // Get last watched episode index for THIS series
  const lastWatchedIndex = getLastWatchedEpisodeIndex(data.id);
  await loadEpisode(lastWatchedIndex);  // â† Load last watched episode
} else {
  player.currentEpisodeId = id;
  await loadMovieSources(data);
}
      } catch (error) {
        console.error('Load error:', error);
        showToast('Failed to load video');
      } finally {
        hideLoading();
      }
    }

async function loadMovieSources(data) {
  const sources = [];
  
  // Check if it's a single quality movie (has lookUrl)
  if (data.lookUrl) {
    // Single quality movie
    const result = await fetchFromWorker(data.lookUrl);
    if (result) {
      sources.push({ quality: '1080p', ...result });
    } else if (data.video) {
      // Fallback to direct URL
      sources.push({ quality: '1080p', videoUrl: data.video, downloadUrl: data.video });
    }
  } else {
    // Multi-quality movie (has 1080Url and/or 720Url)
    if (data['1080Url']) {
      const result = await fetchFromWorker(data['1080Url']);
      if (result) sources.push({ quality: '1080p', ...result });
    }
    
    if (data['720Url']) {
      const result = await fetchFromWorker(data['720Url']);
      if (result) sources.push({ quality: '720p', ...result });
    }

    // Fallback to direct URLs if worker fetch failed
    if (sources.length === 0) {
      if (data.video) sources.push({ quality: '1080p', videoUrl: data.video, downloadUrl: data.video });
      if (data.alt) sources.push({ quality: '720p', videoUrl: data.alt, downloadUrl: data.alt });
    }
  }

  if (sources.length > 0) {
    player.currentSource = sources[0];
    setupQualityOptions(sources); // Will hide quality menu if only 1 source
    loadVideoSource(sources[0].videoUrl, true);
  } else {
    showToast('No video sources available');
  }
}

    async function loadEpisode(index) {
      if (!player.episodes[index]) return;
      
      showLoading();
      const episode = player.episodes[index];
      player.currentEpisodeIndex = index;
      player.currentEpisodeId = player.data.id; // Use series ID instead of episode ID
	  player.currentEpisode = episode.id; // Store actual episode ID separately
      
      document.getElementById('videoTitle').textContent = 
        `S${episode.season}E${episode.episode} - ${episode.title || 'Episode ' + episode.episode}`;
	  document.title = `${player.data.title} - S${episode.season}E${episode.episode} - PanguPlay`;	

      let source = null;
      if (episode.lookUrl) {
        source = await fetchFromWorker(episode.lookUrl);
      }
      
      if (!source && episode.videoUrl) {
        source = { videoUrl: episode.videoUrl, downloadUrl: episode.videoUrl };
      }

      if (source) {
        player.currentSource = source;
        loadVideoSource(source.videoUrl, true);
      } else {
        showToast('Episode source not available');
      }
      
      renderEpisodes();
      updateNextButton();
      hideLoading();
    }

    function loadVideoSource(url, autoplay = false) {
      player.video.src = url;
      player.video.load();
      
player.video.addEventListener('loadedmetadata', () => {
  const resumeTime = getResumeTime();
  if (resumeTime > 0 && resumeTime < player.video.duration - 30) {
    player.video.currentTime = resumeTime;
    showToast(`Resumed from ${formatTime(resumeTime)}`);
  }
  
  // Always show controls when metadata is loaded
  //showControls();
  
  if (autoplay) {
    player.video.play().then(() => {
      // Controls already shown above, will auto-hide after 3s if playing
    }).catch(err => {
      console.log('Autoplay prevented:', err);
      showToast('Click to play');
      // Keep controls visible since video didn't play
      clearTimeout(player.controlsTimeout);
    });
  } else {
    // If not autoplaying, keep controls visible
    clearTimeout(player.controlsTimeout);
  }
}, { once: true });
    }

    // ===== QUALITY SELECTION =====
function setupQualityOptions(sources) {
  const container = document.getElementById('qualityOptions');
  const qualityMenu = document.getElementById('qualityMenu');
  
  container.innerHTML = '';
  
  // Hide quality menu if only one quality available
  if (sources.length <= 1) {
    qualityMenu.style.display = 'none';
    return;
  }
  
  // Show quality menu if multiple qualities
  qualityMenu.style.display = 'flex';
  
  sources.forEach(source => {
    const item = document.createElement('div');
    item.className = 'menu-item quality-option';
    item.textContent = source.quality;
    item.dataset.quality = source.quality;
    item.dataset.url = source.videoUrl;
    item.dataset.download = source.downloadUrl;
    
    if (source.quality === player.currentQuality) {
      item.classList.add('active');
    }
    
    item.onclick = () => changeQuality(source);
    container.appendChild(item);
  });
}

    function changeQuality(source) {
      const currentTime = player.video.currentTime;
      player.currentQuality = source.quality;
      player.currentSource = source;
      
      player.video.src = source.videoUrl;
      player.video.currentTime = currentTime;
      player.video.play();
      
      document.getElementById('currentQuality').textContent = source.quality;
      document.querySelectorAll('.quality-option').forEach(el => el.classList.remove('active'));
      event.target.classList.add('active');
      
      showToast(`Quality: ${source.quality}`);
      hideSettings();
    }

    // ===== ASPECT RATIO =====
    function changeAspectRatio(mode) {
      player.video.className = mode;
      player.aspectMode = mode;
      document.getElementById('currentAspect').textContent = 
        mode.charAt(0).toUpperCase() + mode.slice(1);
      
      document.querySelectorAll('.aspect-option').forEach(el => el.classList.remove('active'));
      event.target.classList.add('active');
      
      showToast(`Aspect: ${mode}`);
      hideSettings();
    }

    // ===== PLAYBACK SPEED =====
    function changeSpeed(speed) {
      player.video.playbackRate = speed;
      document.getElementById('currentSpeed').textContent = speed + 'x';
      
      document.querySelectorAll('.speed-option').forEach(el => el.classList.remove('active'));
      event.target.classList.add('active');
      
      showToast(`Speed: ${speed}x`);
      hideSettings();
    }

    // ===== EPISODES =====
    function renderEpisodes() {
      const grid = document.getElementById('episodeGrid');
      grid.innerHTML = '';
      
      player.episodes.forEach((ep, index) => {
        const btn = document.createElement('button');
        btn.className = 'episode-btn';
        btn.textContent = `EP ${ep.episode}`;
        if (index === player.currentEpisodeIndex) {
          btn.classList.add('active');
        }
        btn.onclick = () => {
          loadEpisode(index);
          toggleEpisodes();
        };
        grid.appendChild(btn);
      });
    }

    function toggleEpisodes() {
      const selector = document.getElementById('episodeSelector');
      const isShowing = selector.classList.toggle('show');
      
      if (isShowing) {
        hideSettings();
        if (player.episodes.length > 0 && selector.children.length <= 1) {
          renderEpisodes();
        }
      }
    }

    function updateNextButton() {
      const nextBtn = document.getElementById('nextEpisodeBtn');
      if (player.episodes.length > 0) {
        nextBtn.style.display = 'block';
        nextBtn.disabled = player.currentEpisodeIndex >= player.episodes.length - 1;
        nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
      } else {
        nextBtn.style.display = 'none';
      }
    }

    function playNextEpisode() {
      if (player.currentEpisodeIndex < player.episodes.length - 1) {
        loadEpisode(player.currentEpisodeIndex + 1);
      }
    }

    // ===== RESUME PLAYBACK =====
    function loadResumeData() {
      const saved = localStorage.getItem('playerResume');
      if (saved) {
        try {
          player.resumeData = JSON.parse(saved);
        } catch (e) {
          player.resumeData = {};
        }
      }
    }

function getResumeTime() {
  if (!player.currentEpisodeId || !player.resumeData[player.currentEpisodeId]) {
    return 0;
  }
  
  const savedData = player.resumeData[player.currentEpisodeId];
  
  if (player.data.type === 'series') {
    // For series: only return time if it's the SAME episode
    if (savedData.episodeId === player.currentEpisode) {
      return savedData.time;
    }
    return 0; // Different episode, start from beginning
  } else {
    // For movies: return saved time
    return savedData.time;
  }
}
	
function getLastWatchedEpisodeIndex(seriesId) {
  if (!seriesId || !player.resumeData[seriesId]) {
    return 0; // No saved data, start from first episode
  }
  
  const savedData = player.resumeData[seriesId];
  
  // Check if we have episode index saved
  if (typeof savedData.episodeIndex === 'number') {
    return savedData.episodeIndex;
  }
  
  // Fallback: try to find by episode ID
  if (savedData.episodeId) {
    const index = player.episodes.findIndex(ep => ep.id === savedData.episodeId);
    return index >= 0 ? index : 0;
  }
  
  return 0; // Default to first episode
}	

function saveResumeTime() {
  if (!player.currentEpisodeId || player.video.currentTime <= 5) return;
  
  if (player.data.type === 'series') {
    // For series: store under series ID with episode details
    player.resumeData[player.currentEpisodeId] = {
      episodeId: player.currentEpisode, // The actual episode ID
      episodeIndex: player.currentEpisodeIndex, // The episode index
      time: player.video.currentTime,
      duration: player.video.duration,
      timestamp: Date.now()
    };
  } else {
    // For movies: store directly under movie ID
    player.resumeData[player.currentEpisodeId] = {
      time: player.video.currentTime,
      duration: player.video.duration,
      timestamp: Date.now()
    };
  }
  
  localStorage.setItem('playerResume', JSON.stringify(player.resumeData));
}

    // ===== CONTROLS =====
    function togglePlayPause() {
      if (player.video.paused) {
        player.video.play();
      } else {
        player.video.pause();
      }
    }

function seek(seconds) {
  player.video.currentTime = Math.max(0, Math.min(player.video.currentTime + seconds, player.video.duration));
  
  // Hide controls immediately if video is playing
  if (!player.video.paused && !player.video.ended) {
    clearTimeout(player.controlsTimeout);
    hideControls();
  }
}

    function toggleMute() {
      player.video.muted = !player.video.muted;
      updateVolumeIcon();
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.querySelector('.video-wrapper').requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    function updateVolumeIcon() {
      const icon = document.getElementById('volumeBtn').querySelector('i');
      if (player.video.muted || player.video.volume === 0) {
        icon.className = 'fas fa-volume-mute';
      } else if (player.video.volume < 0.5) {
        icon.className = 'fas fa-volume-down';
      } else {
        icon.className = 'fas fa-volume-up';
      }
    }

    function updatePlayPauseIcon() {
      const icon = document.getElementById('playPauseBtn').querySelector('i');
      icon.className = player.video.paused ? 'fas fa-play' : 'fas fa-pause';
    }

    function updateProgress() {
      const percent = (player.video.currentTime / player.video.duration) * 100;
      document.getElementById('progressFilled').style.width = percent + '%';
      
      document.getElementById('currentTime').textContent = formatTime(player.video.currentTime);
      document.getElementById('duration').textContent = formatTime(player.video.duration);
      
      // Save resume time periodically
      if (player.video.currentTime % 30 < 0.5) {
        saveResumeTime();
      }
    }

    function updateBuffer() {
      if (player.video.buffered.length > 0) {
        const bufferedEnd = player.video.buffered.end(player.video.buffered.length - 1);
        const percent = (bufferedEnd / player.video.duration) * 100;
        document.getElementById('progressBuffer').style.width = percent + '%';
      }
    }

function formatTime(seconds) {
  if (isNaN(seconds)) return '0:00';
  
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  
  if (hours > 0) {
    return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  } else {
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
}

    // ===== AUTO HIDE CONTROLS =====
function showControls() {
  document.getElementById('controls').classList.add('show');
  document.getElementById('topControls').classList.add('show');
  document.querySelector('.video-wrapper').classList.add('show-cursor');
  
  clearTimeout(player.controlsTimeout);
  
  // Check if video is actually playing (not paused and not ended)
  // Only auto-hide if video is playing and has started (currentTime > 0)
  if (!player.video.paused && !player.video.ended && player.video.currentTime > 0) {
    player.controlsTimeout = setTimeout(() => {
      hideControls();
    }, 1000);
  }
}

function hideControls() {
  if (!player.video.paused && !player.video.ended) {
    document.getElementById('controls').classList.remove('show');
    document.getElementById('topControls').classList.remove('show');
	document.querySelector('.video-wrapper').classList.remove('show-cursor');
  }
}

    // ===== SETTINGS MENU =====
    function toggleSettings() {
      const menu = document.getElementById('settingsMenu');
      menu.classList.toggle('show');
    }

    function hideSettings() {
      document.getElementById('settingsMenu').classList.remove('show');
      document.getElementById('qualityOptions').style.display = 'none';
      document.getElementById('aspectOptions').style.display = 'none';
      document.getElementById('speedOptions').style.display = 'none';
    }

    // ===== ACTIONS =====
    function shareVideo() {
      const url = window.location.href;
      if (navigator.share) {
        navigator.share({
          title: player.data.title,
          url: url
        }).then(() => showToast('Shared successfully'))
          .catch(() => showToast('Share failed'));
      } else {
        navigator.clipboard.writeText(url);
        showToast('Link copied to clipboard');
      }
    }

    function downloadVideo() {
      if (!player.currentSource) {
        showToast('No download source available');
        return;
      }
      
      const a = document.createElement('a');
      a.href = player.currentSource.downloadUrl || player.currentSource.videoUrl;
      a.download = player.data.title + '.mp4';
      a.click();
      showToast('Download started');
    }
	
function copyLink() {
  if (!player.currentSource) {
    showToast('No link available');
    return;
  }
  
  const link = player.currentSource.downloadUrl || player.currentSource.videoUrl;
  navigator.clipboard.writeText(link)
    .then(() => showToast('Link copied to clipboard'))
    .catch(() => showToast('Failed to copy link'));
}	

    function castVideo() {
      if (typeof cast === 'undefined') {
        showToast('Cast not available');
        return;
      }
      
      const session = cast.framework.CastContext.getInstance().getCurrentSession();
      if (session) {
        loadMediaToCast(session);
      } else {
        cast.framework.CastContext.getInstance().requestSession()
          .then(() => loadMediaToCast(cast.framework.CastContext.getInstance().getCurrentSession()))
          .catch(() => showToast('Cast failed'));
      }
    }

    function loadMediaToCast(session) {
      const mediaInfo = new chrome.cast.media.MediaInfo(
        player.currentSource.videoUrl,
        'video/mp4'
      );
      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
      mediaInfo.metadata.title = player.data.title;
      
      const request = new chrome.cast.media.LoadRequest(mediaInfo);
      session.loadMedia(request)
        .then(() => showToast('Casting started'))
        .catch(() => showToast('Cast failed'));
    }

    // ===== UI HELPERS =====
    function showLoading() {
      document.getElementById('loading').classList.add('show');
    }

    function hideLoading() {
      document.getElementById('loading').classList.remove('show');
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 3000);
    }

    function showHUD(icon, text) {
      const hud = document.getElementById('hud');
      const hudIcon = document.getElementById('hudIcon');
      const hudText = document.getElementById('hudText');
      
      hudIcon.className = 'fas ' + icon;
      hudText.textContent = text;
      hud.classList.add('show');
      
      setTimeout(() => hud.classList.remove('show'), 1000);
    }

    // ===== EVENT LISTENERS =====
    function setupEventListeners() {
      // Video events
player.video.addEventListener('play', () => {
  player.isPlaying = true;
  document.body.classList.add('video-loaded');
  updatePlayPauseIcon();
  showControls(); // This will auto-hide after 3s
});
	  
player.video.addEventListener('playing', () => {
  player.isPlaying = true;
  showControls(); // Ensure controls show and will hide after 3s
});

      player.video.addEventListener('pause', () => {
        player.isPlaying = false;
        updatePlayPauseIcon();
        saveResumeTime();
        clearTimeout(player.controlsTimeout);
        showControls();
      });

      player.video.addEventListener('timeupdate', updateProgress);
      player.video.addEventListener('progress', updateBuffer);
      player.video.addEventListener('volumechange', updateVolumeIcon);
      player.video.addEventListener('ended', () => {
        saveResumeTime();
        player.isPlaying = false;
        // Auto-play next episode if available
        if (player.episodes.length > 0 && player.currentEpisodeIndex < player.episodes.length - 1) {
          setTimeout(() => {
            showToast('Playing next episode in 3 seconds...');
            setTimeout(() => {
              loadEpisode(player.currentEpisodeIndex + 1);
            }, 3000);
          }, 1000);
        }
      });

      player.video.addEventListener('loadstart', showLoading);
	  player.video.addEventListener('canplay', hideLoading);

player.video.addEventListener('waiting', showLoading);
player.video.addEventListener('playing', () => {
  hideLoading();
  // Don't show controls during double-tap seek
  if (player.isDoubleTapping) {
    hideControls();
  }
});  

      // Control buttons
      document.getElementById('playPauseBtn').onclick = togglePlayPause;
      document.getElementById('rewindBtn').onclick = () => seek(-10);
      document.getElementById('forwardBtn').onclick = () => seek(10);
      document.getElementById('nextEpisodeBtn').onclick = playNextEpisode;
      document.getElementById('volumeBtn').onclick = toggleMute;
      document.getElementById('fullscreenBtn').onclick = toggleFullscreen;
      document.getElementById('settingsBtn').onclick = toggleSettings;
      document.getElementById('backBtn').onclick = () => window.history.back();
	  document.getElementById('reloadBtn').onclick = () => window.location.reload();
      document.getElementById('shareBtn').onclick = shareVideo;
	  document.getElementById('linkBtn').onclick = copyLink;
      document.getElementById('downloadBtn').onclick = downloadVideo;
      document.getElementById('castBtn').onclick = castVideo;
      document.getElementById('episodesBtn').onclick = toggleEpisodes;

      // Progress bar
      document.getElementById('progressBar').onclick = (e) => {
        const rect = e.currentTarget.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        player.video.currentTime = percent * player.video.duration;
      };

      // Settings menu options
document.getElementById('qualityMenu').onclick = () => {
  const qualityOptions = document.getElementById('qualityOptions');
  const aspectOptions = document.getElementById('aspectOptions');
  const speedOptions = document.getElementById('speedOptions');
  
  // Hide other sections
  aspectOptions.style.display = 'none';
  speedOptions.style.display = 'none';
  
  // Toggle quality options
  qualityOptions.style.display = qualityOptions.style.display === 'none' ? 'block' : 'none';
};

document.getElementById('aspectMenu').onclick = () => {
  const qualityOptions = document.getElementById('qualityOptions');
  const aspectOptions = document.getElementById('aspectOptions');
  const speedOptions = document.getElementById('speedOptions');
  
  // Hide other sections
  qualityOptions.style.display = 'none';
  speedOptions.style.display = 'none';
  
  // Toggle aspect options
  aspectOptions.style.display = aspectOptions.style.display === 'none' ? 'block' : 'none';
};

document.getElementById('speedMenu').onclick = () => {
  const qualityOptions = document.getElementById('qualityOptions');
  const aspectOptions = document.getElementById('aspectOptions');
  const speedOptions = document.getElementById('speedOptions');
  
  // Hide other sections
  qualityOptions.style.display = 'none';
  aspectOptions.style.display = 'none';
  
  // Toggle speed options
  speedOptions.style.display = speedOptions.style.display === 'none' ? 'block' : 'none';
};

      document.querySelectorAll('.aspect-option').forEach(el => {
        el.onclick = () => changeAspectRatio(el.dataset.mode);
      });

      document.querySelectorAll('.speed-option').forEach(el => {
        el.onclick = () => changeSpeed(parseFloat(el.dataset.speed));
      });

      // Double tap to seek
      setupDoubleTap();

      // Keyboard shortcuts
      document.addEventListener('keydown', handleKeyboard);

      // Touch gestures for volume control
      setupTouchGestures();

      // Mouse movement and touch to show controls
const videoWrapper = document.querySelector('.video-wrapper');

let mouseMoveTimeout;
videoWrapper.addEventListener('mousemove', (e) => {
  // Show cursor
  videoWrapper.classList.add('show-cursor');
  
  // Show controls on mouse move
  showControls();
  
  // Clear any existing mousemove timeout
  clearTimeout(mouseMoveTimeout);
  
  // Hide cursor and controls after 2 seconds of no mouse movement (if playing)
  if (!player.video.paused && !player.video.ended) {
    mouseMoveTimeout = setTimeout(() => {
      hideControls();
      videoWrapper.classList.remove('show-cursor'); // ADD THIS LINE
    }, 1000);
  }
});

videoWrapper.addEventListener('mouseleave', () => {
  // Hide cursor when mouse leaves
  videoWrapper.classList.remove('show-cursor'); // ADD THIS LINE
  
  // Hide controls immediately when mouse leaves if video is playing
  if (!player.video.paused && !player.video.ended) {
    clearTimeout(player.controlsTimeout);
    clearTimeout(mouseMoveTimeout);
    hideControls();
  }
});

videoWrapper.addEventListener('touchstart', (e) => {
  // Only show controls if not interacting with tap zones
  if (!e.target.closest('.tap-zone')) {
    showControls();
  }
});

videoWrapper.addEventListener('touchmove', (e) => {
  // Don't show controls during vertical swipe gestures
  // They will be shown when touch ends
});



      // Click video to play/pause
// Use a more specific click handler that doesn't conflict with touch
let clickTimeout;
player.video.addEventListener('click', (e) => {
  // Don't handle if clicking on controls or tap zones
  if (e.target.closest('.controls') || e.target.closest('.tap-zone')) {
    return;
  }
  
  // Prevent double-triggering on mobile
  clearTimeout(clickTimeout);
  clickTimeout = setTimeout(() => {
    // If video is playing, toggle controls visibility
    if (!player.video.paused) {
      const controls = document.getElementById('controls');
      
      // If controls are visible, hide them
      if (controls.classList.contains('show')) {
        hideControls();
        clearTimeout(player.controlsTimeout);
      } else {
        // If controls are hidden, show them briefly
        showControls();
        clearTimeout(player.controlsTimeout);
        player.controlsTimeout = setTimeout(() => {
          hideControls();
        }, 1000);
      }
    } else {
      // If paused, clicking anywhere plays the video
      togglePlayPause();
    }
  }, 10);
});

// Center tap for play/pause on mobile
let centerTapTime = 0;

videoWrapper.addEventListener('touchend', (e) => {
  // Only handle single touch in the center (not on controls or tap zones)
  if (e.target.closest('.controls') || 
      e.target.closest('.tap-zone') || 
      e.target.closest('.top-controls') ||
      e.target.closest('.settings-menu') ||
      e.target.closest('.episode-selector') ||
	  player.isPinching ||
      player.isDoubleTapping) {
    return;
  }
  
  const currentTime = Date.now();
  const timeSinceLastTap = currentTime - centerTapTime;
  
  // Prevent double-tap from triggering play/pause
  if (timeSinceLastTap > 350) {
    e.preventDefault();
    
    // Check if tap is in center area (not left/right 30%)
    const tapX = e.changedTouches[0].clientX;
    const screenWidth = window.innerWidth;
    const leftZone = screenWidth * 0.3;
    const rightZone = screenWidth * 0.7;
    
    if (tapX > leftZone && tapX < rightZone) {
      togglePlayPause();
    } else {
      // Show controls on side taps
      showControls();
      if (!player.video.paused) {
        clearTimeout(player.controlsTimeout);
        player.controlsTimeout = setTimeout(() => {
          hideControls();
        }, 1000);
      }
    }
  }
  
  centerTapTime = currentTime;
}, { passive: false });

      // Close menus when clicking outside
      document.addEventListener('click', (e) => {
        const settingsMenu = document.getElementById('settingsMenu');
        const episodeSelector = document.getElementById('episodeSelector');
        
        if (!e.target.closest('.settings-menu') && !e.target.closest('#settingsBtn')) {
          hideSettings();
        }
        
        if (!e.target.closest('.episode-selector') && !e.target.closest('#episodesBtn')) {
          episodeSelector.classList.remove('show');
        }
      });

      // Fullscreen change
      document.addEventListener('fullscreenchange', () => {
        const icon = document.getElementById('fullscreenBtn').querySelector('i');
        icon.className = document.fullscreenElement ? 'fas fa-compress' : 'fas fa-expand';
      });
    }

    // ===== DOUBLE TAP TO SEEK =====
function setupDoubleTap() {
  let lastTapTime = 0;
  const doubleTapDelay = 300;

  ['tapLeft', 'tapRight'].forEach(id => {
    const zone = document.getElementById(id);
    zone.addEventListener('touchend', (e) => {
      const currentTime = Date.now();
      if (currentTime - lastTapTime < doubleTapDelay) {
        e.preventDefault();
        player.isDoubleTapping = true;
        const seekAmount = id === 'tapLeft' ? -10 : 10;
        seek(seekAmount);
        
        // Reset double tap flag after a delay
        setTimeout(() => {
          player.isDoubleTapping = false;
        }, 400);
      }
      lastTapTime = currentTime;
    });
  });
}

    // ===== TOUCH GESTURES =====
    function setupTouchGestures() {
      let touchStartY = 0;
      let touchStartX = 0;
      let isGesture = false;
      const videoWrapper = document.querySelector('.video-wrapper');

videoWrapper.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;
    isGesture = false;
  } else {
    // Reset gesture tracking when multi-touch detected
    touchStartY = 0;
    touchStartX = 0;
    isGesture = false;
  }
});

      videoWrapper.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && touchStartY !== 0 && !player.isPinching) {
          const deltaY = e.touches[0].clientY - touchStartY;
          const deltaX = e.touches[0].clientX - touchStartX;
          
          // Only handle vertical swipes
          if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > 30) {
            e.preventDefault();
            isGesture = true;
            const isRightSide = touchStartX > window.innerWidth / 2;
            
            if (isRightSide) {
              // Volume control on right side
              const volumeChange = -deltaY / 300;
              player.video.volume = Math.max(0, Math.min(1, player.video.volume + volumeChange));
              showHUD('fa-volume-up', `${Math.round(player.video.volume * 100)}%`);
            } else {
              // Brightness control on left side (visual feedback only)
              const brightnessChange = -deltaY / 300;
			  const currentBrightness = parseFloat(player.video.style.filter.replace('brightness(', '').replace(')', '') || '1');
			  const brightness = Math.max(0.3, Math.min(1, currentBrightness + brightnessChange));
              player.video.style.filter = `brightness(${brightness})`;
              showHUD('fa-sun', `${Math.round(brightness * 100)}%`);
            }
            
            touchStartY = e.touches[0].clientY;
          }
        }
      });

      videoWrapper.addEventListener('touchend', () => {
        touchStartY = 0;
        touchStartX = 0;
        isGesture = false;
      });

      // Pinch to zoom aspect ratio
      let initialDistance = null;
      
      videoWrapper.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          initialDistance = getDistance(e.touches);
		  player.isPinching = true;
        }
      });

      videoWrapper.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2 && initialDistance !== null) {
          e.preventDefault();
		  player.isPinching = true;
          const currentDistance = getDistance(e.touches);
          const diff = currentDistance - initialDistance;

          if (Math.abs(diff) > 30) {
            const mode = diff > 0 ? 'stretch' : 'fit';
            changeAspectRatio(mode);
            initialDistance = null;
          }
        }
      });

      videoWrapper.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
          initialDistance = null;
        }
		
		// Reset pinch flag after a short delay to prevent play/pause trigger
		if (e.touches.length === 0) {
			setTimeout(() => {
			player.isPinching = false;
		  }, 100);
		}
      });
    }

    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // ===== KEYBOARD SHORTCUTS =====
    function handleKeyboard(e) {
      switch(e.key) {
        case ' ':
        case 'k':
		case '5':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'ArrowLeft':
		case '4':
          e.preventDefault();
          seek(-10);
          //showHUD('fa-backward', '-10s');
          break;
        case 'ArrowRight':
		case '6':
          e.preventDefault();
          seek(10);
          //showHUD('fa-forward', '+10s');
          break;
        case 'ArrowUp':
          e.preventDefault();
          player.video.volume = Math.min(1, player.video.volume + 0.1);
          showHUD('fa-volume-up', `${Math.round(player.video.volume * 100)}%`);
          break;
        case 'ArrowDown':
          e.preventDefault();
          player.video.volume = Math.max(0, player.video.volume - 0.1);
          showHUD('fa-volume-down', `${Math.round(player.video.volume * 100)}%`);
          break;
        case 'm':
          toggleMute();
          break;
        case 'f':
		case '8':
		case 'Enter':
          toggleFullscreen();
          break;
        case 'd':
          downloadVideo();
          break;
        case 'n':
		case '9':
          if (player.episodes.length > 0 && player.currentEpisodeIndex < player.episodes.length - 1) {
            loadEpisode(player.currentEpisodeIndex + 1);
          }
          break;
        case 'p':
		case '7':
          if (player.episodes.length > 0 && player.currentEpisodeIndex > 0) {
            loadEpisode(player.currentEpisodeIndex - 1);
          }
          break;
      }
    }

    // ===== CAST API INITIALIZATION =====
    window['__onGCastApiAvailable'] = function(isAvailable) {
      if (isAvailable) {
        cast.framework.CastContext.getInstance().setOptions({
          receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
          autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
        });
      }
    };

    // ===== START APPLICATION =====
    document.addEventListener('DOMContentLoaded', init);

    // Clean up before unload
    window.addEventListener('beforeunload', saveResumeTime);
  </script>
</body>
</html>